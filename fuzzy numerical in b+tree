#include <iostream>
#include <vector>
#include <algorithm>
#include <random>

using namespace std;

struct Interval {
    int start;
    int end;
    int tolerance;

    Interval(int s, int e, int t) : start(s), end(e), tolerance(t) {}
    
    bool contains(int point) const {
        return (point >= start - tolerance) && (point <= end + tolerance);
    }
};

struct Node {
    bool leaf;
    vector<Interval> keys;
    vector<Node*> pointers;

    Node(bool isLeaf) : leaf(isLeaf) {}
};

class IntervalBPlusTree {
private:
    Node* root;

    int findChildIndex(Node* node, const Interval& interval) {
        int index = 0;
        while (index < node->keys.size() && interval.start > node->keys[index].start) {
            ++index;
        }
        return index;
    }

    Node* splitNode(Node* parentNode, Node* fullNode) {
        int mid = fullNode->keys.size() / 2;
        Node* newNode = new Node(fullNode->leaf);

        newNode->keys.assign(fullNode->keys.begin() + mid, fullNode->keys.end());
        fullNode->keys.erase(fullNode->keys.begin() + mid, fullNode->keys.end());
        
        if (!fullNode->leaf) {
            newNode->pointers.assign(fullNode->pointers.begin() + mid, fullNode->pointers.end());
            fullNode->pointers.erase(fullNode->pointers.begin() + mid, fullNode->pointers.end());
        }

        int index = findChildIndex(parentNode, newNode->keys[0]);
        parentNode->pointers.insert(parentNode->pointers.begin() + index + 1, newNode);

        return newNode;
    }

    void insertIntoNode(Node* node, const Interval& interval) {
        int index = lower_bound(node->keys.begin(), node->keys.end(), interval, 
            [](const Interval& a, const Interval& b) { return a.start < b.start; }) - node->keys.begin();
        
        node->keys.insert(node->keys.begin() + index, interval);
    }

public:
    IntervalBPlusTree() {
        root = new Node(true);
    }

    void insert(const Interval& interval) {
        Node* currentNode = root;

        while (!currentNode->leaf) {
            int index = findChildIndex(currentNode, interval);
            currentNode = currentNode->pointers[index];
        }

        insertIntoNode(currentNode, interval);

        if (currentNode->keys.size() > 2) {
            Node* parentNode = root;
            while (!parentNode->leaf) {
                int index = findChildIndex(parentNode, currentNode->keys[0]);
                parentNode = parentNode->pointers[index];
            }
            splitNode(parentNode, currentNode);
        }
    }

    vector<Interval> search(int point) {
        vector<Interval> result;
        Node* currentNode = root;

        while (!currentNode->leaf) {
            int index = 0;
            while (index < currentNode->keys.size() && point > currentNode->keys[index].start) {
                ++index;
            }
            currentNode = currentNode->pointers[index];
        }

        for (const auto& interval : currentNode->keys) {
            if (interval.contains(point)) {
                result.push_back(interval);
            }
        }

        return result;
    }
};

int main() {
    IntervalBPlusTree tree;

    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<int> marks(0, 100);
    uniform_int_distribution<int> tolerance(1, 5);

    for (int i = 0; i < 10; ++i) {
        int start = marks(gen);
        int end = marks(gen);
        int t = tolerance(gen);
        tree.insert(Interval(min(start, end), max(start, end), t));
    }

    int searchPoint = marks(gen);
    vector<Interval> result = tree.search(searchPoint);

    cout << "\nIntervals containing point " << searchPoint << ":" << endl;
    if (result.empty()) {
        cout << "No intervals found." << endl;
    } else {
        for (const auto& interval : result) {
            cout << "Fuzzy Interval [" << interval.start << ", " << interval.end << "] with tolerance " << interval.tolerance << endl;
        }
    }

    return 0;
}
